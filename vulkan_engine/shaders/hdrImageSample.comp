#version 460

layout (local_size_x = 16, local_size_y = 16) in;

layout(set = 0, binding = 0) uniform sampler2D hdrImage;
layout(set = 0, binding = 1, rgba32f) writeonly uniform imageCube cubeMap;

vec2 sampleSphericalMap(vec3 v);

void main() {
	ivec3 storePos = ivec3(gl_GlobalInvocationID.xy, gl_GlobalInvocationID.z); //Pixel position of target cubemap. Z represents the layer count.

    //Converts to Normalized Coordinates
	vec2 uv = (vec2(storePos.xy) + 0.5) / vec2(imageSize(cubeMap).xy); // The 0.5 offset shifts the coords so that they map onto pixel centers instead of pixel corners. Division by image size scales the range to roughly [0.0, 1.0], but with pixel centered offset
	uv = uv * 2.0 - 1.0; //Maps to roughly [-1, 1] range with pixel centered offset

    //Get sample direction, with z/layerCount determining texture and uv.xy sampling the texture
	vec3 direction;
	switch (storePos.z) {
    case 0: direction = normalize(vec3(1.0, -uv.y, -uv.x)); break; // +X
    case 1: direction = normalize(vec3(-1.0, -uv.y, uv.x)); break; // -X
    case 2: direction = normalize(vec3(uv.x, 1.0, uv.y)); break; // +Y
    case 3: direction = normalize(vec3(uv.x, -1.0, -uv.y)); break; // -Y
    case 4: direction = normalize(vec3(uv.x, -uv.y, 1.0)); break; // +Z
    case 5: direction = normalize(vec3(-uv.x, -uv.y, -1.0)); break; // -Z
    default: direction = vec3(0.0); break; // Should not happen
    }

    vec2 sphericalUV = sampleSphericalMap(direction);
    sphericalUV = clamp(sphericalUV, vec2(0.0), vec2(1.0));
    sphericalUV.y = 1.0 - sphericalUV.y; //Invert V coordinates

    vec4 color = texture(hdrImage, sphericalUV);

    imageStore(cubeMap, storePos, color);
}

vec2 sampleSphericalMap(vec3 v) {//v represents the unit circle direction angle
    vec2 invAtan = vec2(0.1591, 0.3183); //The first value represents the reciprocal of 2PI (aka 1/(2PI)). The second is the reciprocal of PI. (1/PI)

    //Transform from Catersian Coords to Polar Angles
    vec2 uv = vec2(atan(v.z, v.x), asin(v.y));

    //Maps Polar Angles to [0,1] UV Range: u = (1/2PI) * phi + 0.5 and v = (1/PI) * theta + 0.5
    uv *= invAtan;
    uv += 0.5;

    return uv;
}